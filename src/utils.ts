export const OPCodeExplanation: { [key: string]: string } = {
  "OP_FALSE": "An empty array of bytes is pushed onto the stack. (This is not a no-op: an item is added to the stack.",
  "OP_0": "An empty array of bytes is pushed onto the stack. (This is not a no-op: an item is added to the stack.",
  "OP_PUSHDATA1": "The next byte contains the number of bytes to be pushed onto the stack.",
  "OP_PUSHDATA2": "The next two bytes contain the number of bytes to be pushed onto the stack in little endian order.",
  "OP_PUSHDATA4": "The next four bytes contain the number of bytes to be pushed onto the stack in little endian order.",
  "OP_1NEGATE": "The number -1 is pushed onto the stack.",
  "OP_RESERVED": "Transaction is invalid unless occuring in an unexecuted OP_IF branch",
  "OP_TRUE": "The number 1 is pushed onto the stack.",
  "OP_1": "The number 1 is pushed onto the stack.",
  "OP_2": "The number 2 is pushed onto the stack.",
  "OP_3": "The number 3 is pushed onto the stack.",
  "OP_4": "The number 4 is pushed onto the stack.",
  "OP_5": "The number 5 is pushed onto the stack.",
  "OP_6": "The number 6 is pushed onto the stack.",
  "OP_7": "The number 7 is pushed onto the stack.",
  "OP_8": "The number 8 is pushed onto the stack.",
  "OP_9": "The number 9 is pushed onto the stack.",
  "OP_10": "The number 10 is pushed onto the stack.",
  "OP_11": "The number 11 is pushed onto the stack.",
  "OP_12": "The number 12 is pushed onto the stack.",
  "OP_13": "The number 13 is pushed onto the stack.",
  "OP_14": "The number 14 is pushed onto the stack.",
  "OP_15": "The number 15 is pushed onto the stack.",
  "OP_16": "The number 16 is pushed onto the stack.",

  // control
  "OP_NOP": "Does nothing.",
  "OP_VER": "Puts the version of the protocol under which this transaction will be evaluated onto the stack.",
  "OP_IF": "[T/F] IF [1] ELSE [2] ENDIF. If the top stack value is TRUE, statement 1 is executed. If the top stack value is FALSE and ELSE is used, statement 2 is executed. If ELSE is NOT used, the script jumps to ENDIF. The top stack value is removed.",
  "OP_NOTIF": "[T/F] NOTIF [1] ELSE [2] ENDIF. If the top stack value is FALSE, statement 1 is executed. If the top stack value is TRUE and ELSE is used, statement 2 is executed. If ELSE is NOT used, the script jumps to ENDIF.The top stack value is removed.",
  "OP_VERIF": "DISABLED.",
  "OP_VERNOTIF": "DISABLED.",
  "OP_ELSE": "[T/F] IF [1] ELSE [2] ENDIF. If the preceding IF or NOTIF check was not valid then statement 2 is executed.",
  "OP_ENDIF": "[T/F] IF [1] ELSE [2] ENDIF. Ends an if/else block. All blocks must end, or the transaction is invalid. An OP_ENDIF without a prior matching OP_IF or OP_NOTIF is also invalid.",
  "OP_VERIFY": "Marks transaction as invalid if top stack value is not true. The top stack value is removed.",
  "OP_RETURN": "Ends script with top value on stack as final result. OP_RETURN can also be used to create \"False Return\" outputs with a scriptPubKey consisting of OP_FALSE OP_RETURN followed by data.",

  // stack ops
  "OP_TOALTSTACK": "Puts the input (top of main stack) onto the top of the alt stack. Removes it from the main stack.",
  "OP_FROMALTSTACK": "Puts the input (top of alt stack) onto the top of the main stack. Removes it from the alt stack.",
  "OP_2DROP": "Removes the top two stack items.",
  "OP_2DUP": "Duplicates the top two stack items.",
  "OP_3DUP": "Duplicates the top three stack items.",
  "OP_2OVER": "Copies the pair of items two spaces back in the stack to the front.",
  "OP_2ROT": "The fifth and sixth items back are moved to the top of the stack.",
  "OP_2SWAP": "Swaps the top two pairs of items.",
  "OP_IFDUP": "If the top stack value is not 0, duplicate it.",
  "OP_DEPTH": "Counts the number of stack items onto the stack and places the value on the top.",
  "OP_DROP": "Removes the top stack item.",
  "OP_DUP": "Duplicates the top stack item.",
  "OP_NIP": "Removes the second-to-top stack item.",
  "OP_OVER": "Copies the second-to-top stack item to the top.",
  "OP_PICK": "The item n (the value at the top of main stack) back in the stack is copied to the top.",
  "OP_ROLL": "The item n back in the stack is moved to the top.",
  "OP_ROT": "The top three items on the stack are rotated to the left.",
  "OP_SWAP": "The top two items on the stack are swapped.",
  "OP_TUCK": "The item at the top of the stack is copied and inserted before the second-to-top item.",

  // data manipulation ops
  "OP_CAT": "Concatenates the top two items (as two strings) on the stack.",
  "OP_SUBSTR": "Replaced in BSV by OP_SPLIT.", // Replaced in BSV
  "OP_SPLIT": "Splits byte sequence x at position n.",
  "OP_LEFT": "Replaced in BSV by OP_NUM2BIN.", // Replaced in BSV
  "OP_NUM2BIN": "Converts numeric value a into byte sequence of length b.",
  "OP_RIGHT": "Replaced in BSV by OP_BIN2NUM.", // Replaced in BSV
  "OP_BIN2NUM": "Converts byte sequence x into a numeric value.",
  "OP_SIZE": "Pushes the string length of the top element of the stack (without popping it).",

  // bit logic
  "OP_INVERT": "Flips all of the bits in the input.",
  "OP_AND": "Boolean and between each bit in the inputs.",
  "OP_OR": "Boolean or between each bit in the inputs.",
  "OP_XOR": "Boolean exclusive or between each bit in the inputs.",
  "OP_EQUAL": "Returns 1 if the inputs are exactly equal, 0 otherwise.",
  "OP_EQUALVERIFY": "Same as OP_EQUAL, but runs OP_VERIFY afterward.",
  "OP_RESERVED1": "Transaction is invalid unless occuring in an unexecuted OP_IF branch",
  "OP_RESERVED2": "Transaction is invalid unless occuring in an unexecuted OP_IF branch",

  // numeric
  "OP_1ADD": "1 is added to the input.",
  "OP_1SUB": "1 is subtracted from the input.",
  "OP_2MUL": "The input is multiplied by 2.",
  "OP_2DIV": "The input is divided by 2.",
  "OP_NEGATE": "The sign of the input is flipped.",
  "OP_ABS": "The input is made positive.",
  "OP_NOT": "If the input is 0 or 1, it is flipped. Otherwise the output will be 0.",
  "OP_0NOTEQUAL": "Returns 0 if the input is 0. 1 otherwise.",

  "OP_ADD": "a is added to b.",
  "OP_SUB": "b is subtracted from a.",
  "OP_MUL": "a is multiplied by b.",
  "OP_DIV": "a is divided by b.",
  "OP_MOD": "Returns the remainder after dividing a by b.",
  "OP_LSHIFT": "Logical left shift b bits. Sign data is discarded",
  "OP_RSHIFT": "Logical right shift b bits. Sign data is discarded",

  "OP_BOOLAND": "If both a and b are not 0, the output is 1. Otherwise 0.",
  "OP_BOOLOR": "If a or b is not 0, the output is 1. Otherwise 0.",
  "OP_NUMEQUAL": "Returns 1 if the numbers are equal, 0 otherwise.",
  "OP_NUMEQUALVERIFY": "Same as OP_NUMEQUAL, but runs OP_VERIFY afterward.",
  "OP_NUMNOTEQUAL": "Returns 1 if the numbers are not equal, 0 otherwise.",
  "OP_LESSTHAN": "Returns 1 if a is less than b, 0 otherwise.",
  "OP_GREATERTHAN": "Returns 1 if a is greater than b, 0 otherwise.",
  "OP_LESSTHANOREQUAL": "Returns 1 if a is less than or equal to b, 0 otherwise.",
  "OP_GREATERTHANOREQUAL": "Returns 1 if a is greater than or equal to b, 0 otherwise.",
  "OP_MIN": "Returns the smaller of a and b.",
  "OP_MAX": "Returns the larger of a and b.",

  "OP_WITHIN": "Returns 1 if x is within the specified range (left-inclusive), 0 otherwise.",

  // crypto
  "OP_RIPEMD160": "The input is hashed using RIPEMD-160.",
  "OP_SHA1": "The input is hashed using SHA-1.",
  "OP_SHA256": "The input is hashed using SHA-256.",
  "OP_HASH160": "The input is hashed twice: first with SHA-256 and then with RIPEMD-160.",
  "OP_HASH256": "The input is hashed two times with SHA-256.",
  "OP_CODESEPARATOR": "All of the signature checking words will only match signatures to the data after the most recently-executed OP_CODESEPARATOR.",
  "OP_CHECKSIG": "The entire transaction's outputs, inputs, and script (from the most recently-executed OP_CODESEPARATOR to the end) are hashed. The signature used by OP_CHECKSIG must be a valid signature for this hash and public key. If it is, 1 is returned, 0 otherwise.",
  "OP_CHECKSIGVERIFY": "Same as OP_CHECKSIG, but OP_VERIFY is executed afterward.",
  "OP_CHECKMULTISIG": "Compares the first signature against each public key until it finds an ECDSA match. Starting with the subsequent public key, it compares the second signature against each remaining public key until it finds an ECDSA match. The process is repeated until all signatures have been checked or not enough public keys remain to produce a successful result. All signatures need to match a public key. Because public keys are not checked again if they fail any signature comparison, signatures must be placed in the scriptSig using the same order as their corresponding public keys were placed in the scriptPubKey or redeemScript. If all signatures are valid, 1 is returned, 0 otherwise. Due to a bug, an extra unused value (x) is removed from the stack. Script spenders must account for this by adding a junk value (typically zero) to the stack.",
  "OP_CHECKMULTISIGVERIFY": "Same as OP_CHECKMULTISIG, but OP_VERIFY is executed afterward.",

  // expansion
  "OP_NOP1": "NO OPERATION",
  "OP_NOP2": "NO OPERATION",
  "OP_NOP3": "NO OPERATION",
  "OP_NOP4": "NO OPERATION",
  "OP_NOP5": "NO OPERATION",
  "OP_NOP6": "NO OPERATION",
  "OP_NOP7": "NO OPERATION",
  "OP_NOP8": "NO OPERATION",
  "OP_NOP9": "NO OPERATION",
  "OP_NOP10": "NO OPERATION",
  "OP_NOP11": "NO OPERATION",
  "OP_NOP12": "NO OPERATION",
  "OP_NOP13": "NO OPERATION",
  "OP_NOP14": "NO OPERATION",
  "OP_NOP15": "NO OPERATION",
  "OP_NOP16": "NO OPERATION",
  "OP_NOP17": "NO OPERATION",
  "OP_NOP18": "NO OPERATION",
  "OP_NOP19": "NO OPERATION",
  "OP_NOP20": "NO OPERATION",
  "OP_NOP21": "NO OPERATION",
  "OP_NOP22": "NO OPERATION",
  "OP_NOP23": "NO OPERATION",
  "OP_NOP24": "NO OPERATION",
  "OP_NOP25": "NO OPERATION",
  "OP_NOP26": "NO OPERATION",
  "OP_NOP27": "NO OPERATION",
  "OP_NOP28": "NO OPERATION",
  "OP_NOP29": "NO OPERATION",
  "OP_NOP30": "NO OPERATION",
  "OP_NOP31": "NO OPERATION",
  "OP_NOP32": "NO OPERATION",
  "OP_NOP33": "NO OPERATION",
  "OP_NOP34": "NO OPERATION",
  "OP_NOP35": "NO OPERATION",
  "OP_NOP36": "NO OPERATION",
  "OP_NOP37": "NO OPERATION",
  "OP_NOP38": "NO OPERATION",
  "OP_NOP39": "NO OPERATION",
  "OP_NOP40": "NO OPERATION",
  "OP_NOP41": "NO OPERATION",
  "OP_NOP42": "NO OPERATION",
  "OP_NOP43": "NO OPERATION",
  "OP_NOP44": "NO OPERATION",
  "OP_NOP45": "NO OPERATION",
  "OP_NOP46": "NO OPERATION",
  "OP_NOP47": "NO OPERATION",
  "OP_NOP48": "NO OPERATION",
  "OP_NOP49": "NO OPERATION",
  "OP_NOP50": "NO OPERATION",
  "OP_NOP51": "NO OPERATION",
  "OP_NOP52": "NO OPERATION",
  "OP_NOP53": "NO OPERATION",
  "OP_NOP54": "NO OPERATION",
  "OP_NOP55": "NO OPERATION",
  "OP_NOP56": "NO OPERATION",
  "OP_NOP57": "NO OPERATION",
  "OP_NOP58": "NO OPERATION",
  "OP_NOP59": "NO OPERATION",
  "OP_NOP60": "NO OPERATION",
  "OP_NOP61": "NO OPERATION",
  "OP_NOP62": "NO OPERATION",
  "OP_NOP63": "NO OPERATION",
  "OP_NOP64": "NO OPERATION",
  "OP_NOP65": "NO OPERATION",
  "OP_NOP66": "NO OPERATION",
  "OP_NOP67": "NO OPERATION",
  "OP_NOP68": "NO OPERATION",
  "OP_NOP69": "NO OPERATION",
  "OP_NOP70": "NO OPERATION",
  "OP_NOP71": "NO OPERATION",
  "OP_NOP72": "NO OPERATION",
  "OP_NOP73": "NO OPERATION",
  "OP_NOP77": "NO OPERATION",

  // template matching params
  "OP_SMALLDATA": "template matching param",
  "OP_SMALLINTEGER": "template matching param",
  "OP_PUBKEYS": "template matching param",
  "OP_PUBKEYHASH": "Represents a public key hashed with OP_HASH160.",
  "OP_PUBKEY": "Represents a public key compatible with OP_CHECKSIG.",

  "OP_INVALIDOPCODE": "Matches any opcode that is not yet assigned."
}

export const OPCodeArgumentCount: { [key: string]: number } = {
  "OP_FALSE": 0,
  "OP_0": 0,
  "OP_PUSHDATA1": 0,
  "OP_PUSHDATA2": 0,
  "OP_PUSHDATA4": 0,
  "OP_1NEGATE": 0,
  "OP_RESERVED": 0,
  "OP_TRUE": 0,
  "OP_1": 0,
  "OP_2": 0,
  "OP_3": 0,
  "OP_4": 0,
  "OP_5": 0,
  "OP_6": 0,
  "OP_7": 0,
  "OP_8": 0,
  "OP_9": 0,
  "OP_10": 0,
  "OP_11": 0,
  "OP_12": 0,
  "OP_13": 0,
  "OP_14": 0,
  "OP_15": 0,
  "OP_16": 0,

  // control
  "OP_NOP": 0,
  "OP_VER": 0,
  "OP_IF": 1,
  "OP_NOTIF": 1,
  "OP_VERIF": 0,
  "OP_VERNOTIF": 0,
  "OP_ELSE": 0,
  "OP_ENDIF": 0,
  "OP_VERIFY": 1,
  "OP_RETURN": 1,

  // stack ops
  "OP_TOALTSTACK": 1,
  "OP_FROMALTSTACK": 0,  // these numbers only consider main stack elements used
  "OP_2DROP": 2,
  "OP_2DUP": 2,
  "OP_3DUP": 3,
  "OP_2OVER": 4,
  "OP_2ROT": 6,
  "OP_2SWAP": 4,
  "OP_IFDUP": 1,
  "OP_DEPTH": 0,
  "OP_DROP": 1,
  "OP_DUP": 1,
  "OP_NIP": 2,
  "OP_OVER": 2,
  "OP_PICK": 1, // special
  "OP_ROLL": 1, // special
  "OP_ROT": 3,
  "OP_SWAP": 2,
  "OP_TUCK": 2,

  // data manipulation ops
  "OP_CAT": 2,
  "OP_SUBSTR": 0,
  "OP_SPLIT": 2,
  "OP_LEFT": 0,
  "OP_NUM2BIN": 2,
  "OP_RIGHT": 0,
  "OP_BIN2NUM": 1,
  "OP_SIZE": 1,

  // bit logic
  "OP_INVERT": 1,
  "OP_AND": 2,
  "OP_OR": 2,
  "OP_XOR": 2,
  "OP_EQUAL": 2,
  "OP_EQUALVERIFY": 2,
  "OP_RESERVED1": 0,
  "OP_RESERVED2": 0,

  // numeric
  "OP_1ADD": 1,
  "OP_1SUB": 1,
  "OP_2MUL": 1,
  "OP_2DIV": 1,
  "OP_NEGATE": 1,
  "OP_ABS": 1,
  "OP_NOT": 1,
  "OP_0NOTEQUAL": 1,

  "OP_ADD": 2,
  "OP_SUB": 2,
  "OP_MUL": 2,
  "OP_DIV": 2,
  "OP_MOD": 2,
  "OP_LSHIFT": 2,
  "OP_RSHIFT": 2,

  "OP_BOOLAND": 2,
  "OP_BOOLOR": 2,
  "OP_NUMEQUAL": 2,
  "OP_NUMEQUALVERIFY": 2,
  "OP_NUMNOTEQUAL": 2,
  "OP_LESSTHAN": 2,
  "OP_GREATERTHAN": 2,
  "OP_LESSTHANOREQUAL": 2,
  "OP_GREATERTHANOREQUAL": 2,
  "OP_MIN": 2,
  "OP_MAX": 2,

  "OP_WITHIN": 3,

  // crypto
  "OP_RIPEMD160": 1,
  "OP_SHA1": 1,
  "OP_SHA256": 1,
  "OP_HASH160": 1,
  "OP_HASH256": 1,
  "OP_CODESEPARATOR": 0,
  "OP_CHECKSIG": 2,
  "OP_CHECKSIGVERIFY": 2,  
  "OP_CHECKMULTISIG": 1,   // special
  "OP_CHECKMULTISIGVERIFY": 1,

  // expansion
  "OP_NOP1": 0,
  "OP_NOP2": 0,
  "OP_NOP3": 0,
  "OP_NOP4": 0,
  "OP_NOP5": 0,
  "OP_NOP6": 0,
  "OP_NOP7": 0,
  "OP_NOP8": 0,
  "OP_NOP9": 0,
  "OP_NOP10": 0,
  "OP_NOP11": 0,
  "OP_NOP12": 0,
  "OP_NOP13": 0,
  "OP_NOP14": 0,
  "OP_NOP15": 0,
  "OP_NOP16": 0,
  "OP_NOP17": 0,
  "OP_NOP18": 0,
  "OP_NOP19": 0,
  "OP_NOP20": 0,
  "OP_NOP21": 0,
  "OP_NOP22": 0,
  "OP_NOP23": 0,
  "OP_NOP24": 0,
  "OP_NOP25": 0,
  "OP_NOP26": 0,
  "OP_NOP27": 0,
  "OP_NOP28": 0,
  "OP_NOP29": 0,
  "OP_NOP30": 0,
  "OP_NOP31": 0,
  "OP_NOP32": 0,
  "OP_NOP33": 0,
  "OP_NOP34": 0,
  "OP_NOP35": 0,
  "OP_NOP36": 0,
  "OP_NOP37": 0,
  "OP_NOP38": 0,
  "OP_NOP39": 0,
  "OP_NOP40": 0,
  "OP_NOP41": 0,
  "OP_NOP42": 0,
  "OP_NOP43": 0,
  "OP_NOP44": 0,
  "OP_NOP45": 0,
  "OP_NOP46": 0,
  "OP_NOP47": 0,
  "OP_NOP48": 0,
  "OP_NOP49": 0,
  "OP_NOP50": 0,
  "OP_NOP51": 0,
  "OP_NOP52": 0,
  "OP_NOP53": 0,
  "OP_NOP54": 0,
  "OP_NOP55": 0,
  "OP_NOP56": 0,
  "OP_NOP57": 0,
  "OP_NOP58": 0,
  "OP_NOP59": 0,
  "OP_NOP60": 0,
  "OP_NOP61": 0,
  "OP_NOP62": 0,
  "OP_NOP63": 0,
  "OP_NOP64": 0,
  "OP_NOP65": 0,
  "OP_NOP66": 0,
  "OP_NOP67": 0,
  "OP_NOP68": 0,
  "OP_NOP69": 0,
  "OP_NOP70": 0,
  "OP_NOP71": 0,
  "OP_NOP72": 0,
  "OP_NOP73": 0,
  "OP_NOP77": 0,

  // template matching params
  "OP_SMALLDATA": 0,
  "OP_SMALLINTEGER": 0,
  "OP_PUBKEYS": 0,
  "OP_PUBKEYHASH": 0,
  "OP_PUBKEY": 0,

  "OP_INVALIDOPCODE": 0
}

export function minBytesNeededToPushDataOfLength(dataLengthInBytes: number) : number {
  if (dataLengthInBytes < 0) throw new Error("Data length cannot be negative");
  // this function calculates the minimum number of bytes needed to push data of given bytes onto the stack
  // To push (1~75 bytes) needs (1 byte for length, X bytes for data)
  //      e.g 0x123456 turns into 0x03123456 
  if (dataLengthInBytes < 76) return 1 + dataLengthInBytes;
  // To push (76~255 bytes) needs (1 byte for OP_PUSHDATA1, 1 byte for length, X bytes for data)
  //      e.g 0x[76 bytes of data] turns into 0x4c[1 byte for length][76 bytes of data]
  if (dataLengthInBytes < 256) return 1 + 1 + dataLengthInBytes;
  // To push (256~65535 bytes) needs (1 byte for OP_PUSHDATA2, 2 bytes for length, X bytes for data)
  //      e.g 0x[256 bytes of data] turns into 0x4d[2 bytes for length][256 bytes of data]
  if (dataLengthInBytes < 65536) return 1 + 2 + dataLengthInBytes;
  // To push (65536~4294967295 bytes) needs (1 byte for OP_PUSHDATA4, 4 bytes for length, X bytes for data)
  //      e.g 0x[65536 bytes of data] turns into 0x4e[4 bytes for length][65536 bytes of data]
  if (dataLengthInBytes < 4294967296) return 1 + 4 + dataLengthInBytes;
  throw new Error("Data length too long");
}